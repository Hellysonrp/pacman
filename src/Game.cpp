/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/


#include "Game.h"
#include "Position.h"
#include "PathUtils.h"
#include <vector>
#include <filesystem>

#define PAC	1
#define GHOST1 2
#define GHOST2 3
#define GHOST3 4
#define GHOST4 5

extern Log logtxt;
extern App app;
extern Settings settings;

void Game::editorSave() {
    int i=-1, j=-1;

    if ( settings.baddiestartx == -1 ||
         settings.baddiestarty == -1 ||
         settings.pacstartx == -1 ||
         settings.pacstarty == -1 ) {
        std::cerr << "Specify pacman and ghost start locations before saving\n";
        return;
    }

    //save

    std::ofstream file;
    bool error=0;		//1 on error


    if (editorpath.empty()) editorpath = std::filesystem::path("levels") / "new";
    file.open(editorpath / MAPFILE);

    if (!file) error=true;

    if (!error) {
        file << "/ Pacman Revolutions mapfile generated by Pacman level editor"	<< std::endl;
        for (j=0;j<settings.fieldheight; j++) {
            for (i=0;i<settings.fieldwidth; i++) {
                file << map[j*settings.fieldwidth+i] << "  ";
            }
            file << std::endl;
        }
    }

    if (file.is_open() ) file.close();


    file.open(editorpath / OBJFILE);
    if (!file) error=1;

    if (!error) {
        file << "/ Pacman Revolutions objectmap generated by Pacman level editor"	<< std::endl;
        for (j=0;j<settings.fieldheight; j++) {
            for (i=0;i<settings.fieldwidth; i++) {
                file << objmap[j*settings.fieldwidth+i] << "  ";
            }
            file << std::endl;
        }
    }

    if (file.is_open() ) file.close();

    file.open(editorpath / CFGFILE);
    if (!file) error=true;

    if (!error) {
        file << "/ Pacman Revolutions config file generated by Pacman level editor =;"	<< std::endl;
        file << "FIELDWIDTH=" << settings.fieldwidth << ";" << std::endl;
        file << "FIELDHEIGHT=" << settings.fieldheight << ";" << std::endl;
        file << "TILESIZE=" << settings.tilesize << ";" << std::endl;
        file << "PACSPEED=" << settings.pacspeed << ";" << std::endl;
        file << "BADDIESPEED=" << settings.baddiespeed << ";" << std::endl;
        file << "BADDIEIQ=" << settings.baddieiq << ";" << std::endl;
        file << "VULN_DURATION=" << settings.vuln_duration << ";" << std::endl;
        file << "PACSTARTX=" << settings.pacstartx  << ";" << std::endl;
        file << "PACSTARTY=" << settings.pacstarty << ";" << std::endl;
        file << "BADDIESTARTX=" << settings.baddiestartx << ";" << std::endl;
        file << "BADDIESTARTY=" << settings.baddiestarty << ";" << std::endl;
    }
    if ( file.is_open() ) file.close();

    bool isincluded = false;
    for (const auto& path : settings.lvlpath) {
        if (editorpath == path) {
            isincluded = true;
            break;
        }
    }
    if ( !isincluded && !error) {
        file.open("pacman.cfg", std::ios::out | std::ios::app);
        if (!file) error=true;
        else {
            file << "\nLEVEL_PATH=" << editorpath.string();
            if (file.is_open()) file.close();
            settings.lvlpath.push_back(editorpath);
        }
    }


    if (error) {
        std::cerr << "Save failed";
    }
}

void Game::logicEditor() {

    if ( inputwaiting) {
        if ( key == LEFT ) {

            if ( activetool == 0 ) activetool = 15;
            else activetool--;
        }
        else if ( key == RIGHT ) {

            if ( activetool == 15 ) activetool = 0;
            else activetool++;
        }
        else if ( key == CLICK ) {
            if (activetool < 10)
                map[settings.fieldwidth*(mouseY / settings.tilesize)+(mouseX / settings.tilesize)] = activetool;
            else if (activetool == 14) {
                settings.pacstartx = mouseX / settings.tilesize;
                settings.pacstarty = mouseY / settings.tilesize;
            }
            else if (activetool == 15 ) {
                settings.baddiestartx = mouseX / settings.tilesize;
                settings.baddiestarty = mouseY / settings.tilesize;
            }
            else
                objmap[settings.fieldwidth*((mouseY - 10) / settings.tilesize)+((mouseX-10) / settings.tilesize)] = activetool-10;
        }
    }

}

void Game::renderEditor() {
    int i;

    objects[0]->Draw();

    for (i=1;i<10;i++) {
        if ( i == activetool )
            ((BckgrObj*)objects[0])->Draw( 10 + 30*i, settings.fieldheight * settings.tilesize + 5 , i, 0, 255);
        else
            ((BckgrObj*)objects[0])->Draw( 10 + 30*i, settings.fieldheight * settings.tilesize + 5 , i, 0, 100);
    }
    for (i=1;i<4;i++) {
        if ( i == activetool - 10 )
            ((BckgrObj*)objects[0])->Draw( 310 + 30*i, settings.fieldheight * settings.tilesize + 5 , i, 1, 255);
        else
            ((BckgrObj*)objects[0])->Draw( 310 + 30*i, settings.fieldheight * settings.tilesize + 5 , i, 1, 100);
    }
    if ( activetool == 14 ) {
        objects[PAC]->setAlpha(255);
        objects[PAC]->Draw(430, settings.fieldheight * settings.tilesize + 5 );
    }
    else {
        objects[PAC]->setAlpha(100);
        objects[PAC]->Draw(430, settings.fieldheight * settings.tilesize + 5 );
    }
    if ( activetool == 15 ) {
        objects[GHOST1]->setAlpha(255);
        objects[GHOST1]->Draw(480, settings.fieldheight * settings.tilesize + 5 );
    }
    else {
        objects[GHOST1]->setAlpha(100);
        objects[GHOST1]->Draw(480, settings.fieldheight * settings.tilesize + 5 );
    }

    objects[PAC]->Draw(settings.pacstartx*settings.tilesize, settings.pacstarty * settings.tilesize );
    objects[GHOST1]->Draw(settings.baddiestartx * settings.tilesize, settings.baddiestarty * settings.tilesize);

}

void Game::initEditor() {
    int i;

    if ( map ) delete[] map;
    if ( objmap ) delete[] objmap;

    //create new empty maps
    if ( editorpath.empty() ) {
        map = new int[ settings.fieldheight * settings.fieldwidth ];
        objmap = new int[ settings.fieldheight * settings.fieldwidth ];

        for (i=0;i<settings.fieldheight * settings.fieldwidth;i++) {
            map[i]=0;
            objmap[i]=0;
        }
        settings.baddiestartx = -1;
        settings.baddiestarty = -1;
        settings.pacstartx = -1;
        settings.pacstarty = -1;
        settings.gatex = -1;
        settings.gatey = -1;
    }
    //load existing map
    else {

        //load settings

        settings.LoadSettings( (editorpath / CFGFILE).string() );

        //if level has different field size than currently selected, setup new window with proper size
        int winW, winH;
        SDL_GetWindowSize(app.getWindow(), &winW, &winH);
        if (settings.fieldwidth*settings.tilesize != winW
            || settings.fieldheight*settings.tilesize+EXTRA_Y_SPACE != winH) {
            app.InitWindow();
            logtxt.print("window resized...");
        }

        //load maps

        map = new int[ settings.fieldheight * settings.fieldwidth ];
        objmap = new int[ settings.fieldheight * settings.fieldwidth ];

        loadMap( (editorpath / MAPFILE).string(), map);
        loadMap( (editorpath / OBJFILE).string(), objmap);

        //if loading is successful, set editorpath

    }

}
void Game::changeSkin() {
    int i;
    for (i=0;i<NUMOFOBJECTS;i++) objects[i]->LoadTextures( (PathUtils::getAppPath() / settings.skinspath[settings.skinspathcurrent]).string() );
}
void Game::emptyMsgPump() {

    SDL_Event ev;

    while ( SDL_PollEvent(&ev) == 1 ) {
        switch(ev.type) {
        case SDL_KEYDOWN:
            handleKeyDown(ev.key);
            break;
        case SDL_MOUSEBUTTONDOWN:
            handleMouseButton(ev.button);
            break;
        case SDL_MOUSEMOTION:
            handleMouseMotion(ev.motion);
            break;
        default:
            break;
        }
    }
}

void Game::handleKeyDown(const SDL_KeyboardEvent& keyEvent) {
    if ( getState() == STATE_MENU ) {
        switch (keyEvent.keysym.sym) {
        case SDLK_UP:
            processInput(UP);
            break;
        case SDLK_DOWN:
            processInput(DOWN);
            break;
        case SDLK_RETURN:
        case SDLK_SPACE:
            processInput(ENTER);
            break;
        case SDLK_ESCAPE:
        case SDLK_q:
            app.setQuit(true);
            break;
        default:
            break;
        }
        return;
    }

    // Permite sair do leaderboard de volta para o menu usando ESC sem encerrar o jogo.
    if ( getState() == STATE_VIEW_HSCORE && keyEvent.keysym.sym == SDLK_ESCAPE ) {
        previousState = STATE_MENU;
        rankingFromHotkey = false;
        setState( STATE_MENU );
        return;
    }
    switch (keyEvent.keysym.sym) {
    case SDLK_ESCAPE:
        break;
    case SDLK_q:
        app.setQuit(true);
        break;
    case SDLK_UP:
        handleMovementKey(UP);
        break;
    case SDLK_DOWN:
        handleMovementKey(DOWN);
        break;
    case SDLK_LEFT:
        handleMovementKey(LEFT);
        break;
    case SDLK_RIGHT:
        handleMovementKey(RIGHT);
        break;
    case SDLK_SPACE:
        boost();
        break;
    case SDLK_p:
        if ( getState() == STATE_GAME )
            pause();
        break;
    case SDLK_n:
        if ( getState() != STATE_ENTER_HSCORE )
            gameInit();
        break;
    case SDLK_l:
        if (!settings.lvlpath.empty()) {
            settings.lvlpathcurrent++;
            if (settings.lvlpathcurrent >= static_cast<int>(settings.lvlpath.size()))
                settings.lvlpathcurrent=0;
        }
        gameInit();
        break;
    case SDLK_s:
        if (!settings.skinspath.empty()) {
            settings.skinspathcurrent++;
            if (settings.skinspathcurrent >= static_cast<int>(settings.skinspath.size()))
                settings.skinspathcurrent=0;
        }
        changeSkin();
        break;
    case SDLK_e:
        initEditor();
        setState( STATE_EDITOR );
        break;
    case SDLK_w:
        editorSave();
        break;
    case SDLK_f:
        toggleFps();
        break;
    case SDLK_h:
        if ( state == STATE_ENTER_HSCORE )
            break;

        if ( state == STATE_VIEW_HSCORE && rankingFromHotkey ) {
            setState( previousState );
            rankingFromHotkey = false;
        }
        else {
            previousState = state;
            rankingFromHotkey = (state != STATE_VIEW_HSCORE);
            if (rankingFromHotkey)
                hasRecentGameOver = false;
            setState( STATE_VIEW_HSCORE );
        }
        break;
    case SDLK_RETURN:
        processInput(ENTER);
        break;
    default:
        break;
    }
}

void Game::handleMouseButton(const SDL_MouseButtonEvent& buttonEvent) {
    if ( getState() == STATE_EDITOR )
        processInput( CLICK, buttonEvent.x , buttonEvent.y);
}

void Game::handleMouseMotion(const SDL_MouseMotionEvent& motionEvent) {
    if ( getState() == STATE_EDITOR && motionEvent.state&SDL_BUTTON(1) )
        processInput( CLICK, motionEvent.x, motionEvent.y);
}

void Game::handleMovementKey(int direction) {
    processInput(direction);
    ((Pacman*)objects[PAC])->setNextDir( direction );
}
void Game::toggleSound() {

    if ( app.getSnd()->on) {
        app.getSnd()->toggleSounds();
    }
    else {
        app.getSnd()->toggleSounds();

        if (gamestarted && !ispaused ) app.getSnd()->play(10, 1);
        if (gamestarted && vulnflag && !ispaused ) app.getSnd()->play(7, 1);
    }
}
void Game::clearHscore() {
    hscore.clear();
}

void Game::renderViewHscore() {
    SDL_Renderer* renderer = app.getRenderer();
    shared_ptr<SDL_Surface> txt;
    SDL_Texture* texture;
    SDL_Color col,
            highlightCol;
    std::ostringstream ostr, scstr;
    SDL_Rect rect,
            entryRect,
            instructionRect;
    std::vector<hScore::ScoreEntry> entries = hscore.getEntries();
    int i;

    col.r = col.g = col.b = 255;
    highlightCol.r = 255;
    highlightCol.g = 215;
    highlightCol.b = 0;

    rect.x = settings.fieldwidth*settings.tilesize / 2 - 220;
    rect.w = 440;
    rect.y = settings.fieldheight*settings.tilesize / 2 - 220;
    rect.h = 40;

    try {
        // DRAW FIELD + SPRITES

        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->Draw();

        // DRAW SCORE + INFO

        for (i=1; i<lives; i++) {
            objects[PAC]->Draw( 350+i*50, settings.fieldheight*settings.tilesize);
        }
        if ( specialeaten ) objects[0]->Draw( settings.fieldwidth*settings.tilesize - 40 -10, settings.fieldheight*settings.tilesize +10 );

        if (hasRecentGameOver)
            ostr << "PONTUAÇÃO FINAL: " << lastRecordedScore;
        else
            ostr << "level: " << level << " score: " << score;

        txt.reset(TTF_RenderUTF8_Solid(font,ostr.str().c_str(),col), SDL_FreeSurface);
        if (!txt) throw Error("DrawText failed");
        texture = SDL_CreateTextureFromSurface(renderer, txt.get());
        if (texture) {
            SDL_Rect textRect = {scorebox.x, scorebox.y, txt->w, txt->h};
            SDL_RenderCopy(renderer, texture, NULL, &textRect);
            SDL_DestroyTexture(texture);
        }

        if (hasRecentGameOver) {
            ostr.str("");
            ostr << "GAME OVER - PONTOS: " << lastRecordedScore;
            txt.reset(TTF_RenderUTF8_Solid(font,ostr.str().c_str(),col), SDL_FreeSurface);
            if (!txt) throw Error("DrawText failed");
            texture = SDL_CreateTextureFromSurface(renderer, txt.get());
            if (texture) {
                SDL_Rect textRect = {rect.x, rect.y, txt->w, txt->h};
                SDL_RenderCopy(renderer, texture, NULL, &textRect);
                SDL_DestroyTexture(texture);
            }
            rect.y += 50;
        }

        txt.reset(TTF_RenderUTF8_Solid(font,"HIGHSCORES:",col), SDL_FreeSurface);
        if (!txt) throw Error("DrawText failed");
        texture = SDL_CreateTextureFromSurface(renderer, txt.get());
        if (texture) {
            SDL_Rect textRect = {rect.x, rect.y, txt->w, txt->h};
            SDL_RenderCopy(renderer, texture, NULL, &textRect);
            SDL_DestroyTexture(texture);
        }
        rect.y += 40;

        entryRect.x = settings.fieldwidth * settings.tilesize / 2 - 200;
        entryRect.w = 60;
        entryRect.y = rect.y;
        entryRect.h = 40;

        for (i=0;i<MAXENTRIES;i++) {
            std::ostringstream positionStream;
            SDL_Color activeColor = col;

            if (i < static_cast<int>(entries.size())) {
                const hScore::ScoreEntry& entry = entries[i];
                bool highlightEntry = !lastRecordedName.empty() &&
                        entry.playerName == lastRecordedName && entry.playerScore == lastRecordedScore;
                // Mantém o destaque do recorde mais recente mesmo depois que a próxima partida já estiver preparada.
                if (highlightEntry) {
                    activeColor = highlightCol;
                }

                positionStream << (i+1) << "º";
                txt.reset(TTF_RenderUTF8_Solid(font,positionStream.str().c_str(),activeColor), SDL_FreeSurface);
                if (!txt) throw Error("DrawText failed");
                texture = SDL_CreateTextureFromSurface(renderer, txt.get());
                if (texture) {
                    SDL_Rect textRect = {entryRect.x, entryRect.y, txt->w, txt->h};
                    SDL_RenderCopy(renderer, texture, NULL, &textRect);
                    SDL_DestroyTexture(texture);
                }

                SDL_Rect nameRect = entryRect;
                nameRect.x += 70;
                std::string nameToShow = entry.playerName.empty() ? "---" : entry.playerName;
                txt.reset(TTF_RenderUTF8_Solid(font,nameToShow.c_str(),activeColor), SDL_FreeSurface);
                if (!txt) throw Error("DrawText failed");
                texture = SDL_CreateTextureFromSurface(renderer, txt.get());
                if (texture) {
                    SDL_Rect textRect = {nameRect.x, nameRect.y, txt->w, txt->h};
                    SDL_RenderCopy(renderer, texture, NULL, &textRect);
                    SDL_DestroyTexture(texture);
                }

                SDL_Rect scoreRect = entryRect;
                scoreRect.x += 240;
                scstr.str("");
                scstr << entry.playerScore;
                txt.reset(TTF_RenderUTF8_Solid(font,scstr.str().c_str(),activeColor), SDL_FreeSurface);
                if (!txt) throw Error("DrawText failed");
                texture = SDL_CreateTextureFromSurface(renderer, txt.get());
                if (texture) {
                    SDL_Rect textRect = {scoreRect.x, scoreRect.y, txt->w, txt->h};
                    SDL_RenderCopy(renderer, texture, NULL, &textRect);
                    SDL_DestroyTexture(texture);
                }
            }

            entryRect.y += 40;
        }

        instructionRect.x = settings.fieldwidth * settings.tilesize / 2 - 220;
        instructionRect.w = 440;
        instructionRect.y = entryRect.y + 20;
        instructionRect.h = 40;

        if (hasRecentGameOver) {
            const char* restartMsg = "Pressione N para iniciar uma nova partida";
            txt.reset(TTF_RenderUTF8_Solid(font,restartMsg,col), SDL_FreeSurface);
            if (!txt) throw Error("DrawText failed");
            texture = SDL_CreateTextureFromSurface(renderer, txt.get());
            if (texture) {
                SDL_Rect textRect = {instructionRect.x, instructionRect.y, txt->w, txt->h};
                SDL_RenderCopy(renderer, texture, NULL, &textRect);
                SDL_DestroyTexture(texture);
            }
        }
        else if (rankingFromHotkey) {
            const char* backMsg = "Pressione H novamente para voltar";
            txt.reset(TTF_RenderUTF8_Solid(font,backMsg,col), SDL_FreeSurface);
            if (!txt) throw Error("DrawText failed");
            texture = SDL_CreateTextureFromSurface(renderer, txt.get());
            if (texture) {
                SDL_Rect textRect = {instructionRect.x, instructionRect.y, txt->w, txt->h};
                SDL_RenderCopy(renderer, texture, NULL, &textRect);
                SDL_DestroyTexture(texture);
            }
        }

        // Destaca o atalho ESC quando o leaderboard é acessado pelo menu principal.
        instructionRect.y += 40;
        const char* escMsg = "ESC volta para o menu principal";
        txt.reset(TTF_RenderUTF8_Solid(font,escMsg,col), SDL_FreeSurface);
        if (!txt) throw Error("DrawText failed");
        texture = SDL_CreateTextureFromSurface(renderer, txt.get());
        if (texture) {
            SDL_Rect textRect = {instructionRect.x, instructionRect.y, txt->w, txt->h};
            SDL_RenderCopy(renderer, texture, NULL, &textRect);
            SDL_DestroyTexture(texture);
        }

    }
    catch ( Error& err ) {
        std::cerr << err.getDesc();
        app.setQuit(true);
        logtxt.print( err.getDesc() );
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in RenderViewHscore";
        app.setQuit(true);
        logtxt.print( "Unexpected error" );
    }
}

void Game::renderMenu() {
    SDL_Renderer* renderer = app.getRenderer();
    shared_ptr<SDL_Surface> txt;
    SDL_Texture* texture;
    SDL_Color primaryColor,
            highlightColor,
            frameColor;
    SDL_Rect lineRect,
            optionRect,
            hintRect,
            backdropRect;
    int winW, winH;

    TTF_Font* menuFace = menuFont ? menuFont : font;

    primaryColor.r = 255; primaryColor.g = 255; primaryColor.b = 0;
    highlightColor.r = 0; highlightColor.g = 255; highlightColor.b = 255;
    frameColor.r = 255; frameColor.g = 215; frameColor.b = 0;

    const std::vector<std::string> frame = {
        "#############################",
        "#                           #",
        "#       PAC-MAN SDL         #",
        "#        MAIN MENU          #",
        "#                           #",
        "#############################"
    };

    const int centerX = settings.fieldwidth * settings.tilesize / 2;
    const int centerY = settings.fieldheight * settings.tilesize / 2;

    SDL_GetWindowSize(app.getWindow(), &winW, &winH);

    optionRect.x = 0;
    optionRect.y = 0;
    optionRect.w = 0;
    optionRect.h = 40;

    lineRect.x = 0;
    lineRect.y = centerY - static_cast<int>(frame.size() * 15); // Metade da altura total da moldura (6 linhas * 30px / 2).
    lineRect.w = 0;
    lineRect.h = 30;

    hintRect.x = 0;
    hintRect.y = 0;
    hintRect.w = 0;
    hintRect.h = 30;

    backdropRect.x = 0;
    backdropRect.y = 0;
    backdropRect.w = winW;
    backdropRect.h = winH;

    try {
        renderNormal();

        // Draw semi-transparent backdrop overlay using SDL 2.0 renderer
        SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 160);
        SDL_RenderFillRect(renderer, &backdropRect);

        for (const std::string& line : frame) {
            txt.reset(TTF_RenderUTF8_Solid(menuFace, line.c_str(), frameColor), SDL_FreeSurface);
            if (!txt) throw Error("DrawText failed");
            texture = SDL_CreateTextureFromSurface(renderer, txt.get());
            if (texture) {
                SDL_Rect centeredLine = {centerX - txt->w / 2, lineRect.y, txt->w, txt->h};
                SDL_RenderCopy(renderer, texture, NULL, &centeredLine);
                SDL_DestroyTexture(texture);
            }
            lineRect.y += 30;
        }

        // Reposiciona os blocos subsequentes de forma derivada para evitar sobreposição visual.
        const int frameBottom = lineRect.y; // lineRect acumulou a altura da moldura.
        optionRect.y = frameBottom + 10;

        const std::vector<std::string> options = {"INICIAR JOGO", "LEADERBOARD", "SAIR"};

        for (size_t i = 0; i < options.size(); ++i) {
            std::string label = options[i];
            if (static_cast<int>(i) == menuSelection)
                label = "> " + label + " <"; // Destaque textual simples para o item ativo.

            SDL_Color activeColor = (static_cast<int>(i) == menuSelection) ? highlightColor : primaryColor;
            // Opções usam a fonte apenas neste menu para não afetar outras telas.
            txt.reset(TTF_RenderUTF8_Solid(menuFace, label.c_str(), activeColor), SDL_FreeSurface);
            if (!txt) throw Error("DrawText failed");
            texture = SDL_CreateTextureFromSurface(renderer, txt.get());
            if (texture) {
                SDL_Rect centeredOption = {centerX - txt->w / 2, optionRect.y, txt->w, txt->h};
                SDL_RenderCopy(renderer, texture, NULL, &centeredOption);
                SDL_DestroyTexture(texture);
            }
            optionRect.y += 40;
        }

        // txt.reset(TTF_RenderUTF8_Solid(menuFace, "Use as setas, ENTER e ESC", primaryColor), SDL_FreeSurface);
        // if (!txt) throw Error("DrawText failed");
        // texture = SDL_CreateTextureFromSurface(renderer, txt.get());
        // if (texture) {
        //     SDL_Rect centeredHint = hintRect;
        //     centeredHint.y = optionRect.y + 20; // Hints ficam abaixo do último item para manter respiro.
        //     centeredHint.x = centerX - txt->w / 2;
        //     SDL_RenderCopy(renderer, texture, NULL, &centeredHint);
        //     SDL_DestroyTexture(texture);
        // }
    }
    catch ( Error& err ) {
        std::cerr << err.getDesc();
        app.setQuit(true);
        logtxt.print( err.getDesc() );
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in RenderMenu";
        app.setQuit(true);
        logtxt.print( "Unexpected error during RenderMenu()" );
    }
}

void Game::setState(int st) {
    int i;

    if ( st == STATE_GAME ) {
        app.getSnd()->stop();
        app.getSnd()->play(10,1);

        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(255);
        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->setPaused( false);

    }
    else if ( st == STATE_ENTER_HSCORE ) {

        app.getSnd()->stop();

        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->setPaused( true);
        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(150);

    }
    else if ( st == STATE_VIEW_HSCORE ) {


        app.getSnd()->stop();
        app.getSnd()->play( 11, 0);

        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(150);
        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->setPaused( true);
    }
    else if ( st == STATE_STOPPED && state != STATE_STOPPED) {
        app.getSnd()->stop();
        app.getSnd()->play(0, 1);
        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->setPaused( true);
        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(255);
    }
    else if ( st == STATE_MENU ) {
        app.getSnd()->stop();
        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->setPaused( true); // Congela sprites enquanto o menu é exibido.
        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(255);
    }
    else if ( st == STATE_EDITOR ) {

        app.getSnd()->stop();

        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(255);

        activetool = 1;
    }

    state = st;

}

void Game::logicEnterHscore() {
    int j;

    if ( inputwaiting ) {

        switch ( key ) {
        case RIGHT :
            if (hscoreselection==2) hscoreselection=0;
            else hscoreselection++;
            for (j=0;j<3;j++) namecol[j]= 150;
            namecol[ hscoreselection ] = 255;
            break;
        case LEFT :
            if (hscoreselection==0) hscoreselection=2;
            else hscoreselection--;
            for (j=0;j<3;j++) namecol[j]= 150;
            namecol[ hscoreselection ] = 255;
            break;
        case DOWN :
            if (name[hscoreselection]=='A') name[hscoreselection]='_';
            else if (name[hscoreselection]=='_') name[hscoreselection]='Z';
            else name[hscoreselection]--;
            break;
        case UP :
            if (name[hscoreselection]=='Z') name[hscoreselection]='_';
            else if (name[hscoreselection]=='_') name[hscoreselection]='A';
            else name[hscoreselection]++;
            break;
        case ENTER :
            hscore.add(name, lastRecordedScore);
            hscore.save();
            awaitingHighscoreEntry = false;
            lastRecordedName = name;
            rankingFromHotkey = false;
            hasRecentGameOver = false; // Ao confirmar o nome reiniciamos o ciclo de jogo imediatamente.
            gamestarted = false; // Garante que a próxima partida possa iniciar sem depender de pressionar 'N'.
            previousState = STATE_STOPPED;
            setState( STATE_STOPPED );
        default :
             break;
        }
    }
}
void Game::logicGame() {
    int
            i, j,
            delta,
            pacX,
            pacY,
            pacXpix,
            pacYpix,
            ghostXpix[4],
            ghostYpix[4],
            oldscore(score);

    delta = (int)(time -oldtime);

    if ( gamestarted && !ispaused ) {

        //////////////////////////////////
        //	GET POSITIONS
        //////////////////////////////////

        pacXpix = ((Pacman*)objects[PAC])->getXpix();
        pacYpix = ((Pacman*)objects[PAC])->getYpix();
        pacX= (pacXpix + settings.tilesize / 2) / settings.tilesize;
        pacY= (pacYpix + settings.tilesize / 2) / settings.tilesize;
        for (i=0;i<4;i++) {
            ghostXpix[i]= ((Ghost*)objects[i+2])->getXpix();
            ghostYpix[i]= ((Ghost*)objects[i+2])->getYpix();
        }

        //////////////////////////////////
        // MOVE LOGIC
        //////////////////////////////////

        if ( delta < 100 )  {
            //set ghost targets - 2 on pacman, 2 on next intersection

            {
                int tmpx(  pacXpix / settings.tilesize),
                tmpy(  pacYpix / settings.tilesize);

                ((Ghost*)objects[GHOST1])->setTarget( tmpx, tmpy);
                ((Ghost*)objects[GHOST2])->setTarget( tmpx, tmpy);

                ((Pacman*)objects[PAC])->nextIntersection ( tmpx, tmpy);

                ((Ghost*)objects[GHOST3])->setTarget( tmpx, tmpy);
                ((Ghost*)objects[GHOST4])->setTarget( tmpx, tmpy);
            }

            //move objects

            for (i=0;i<NUMOFOBJECTS;i++)
                objects[i]->Update( delta );
        }
        ///////////////////////////////////////////
        //	TIME LOGIC
        ///////////////////////////////////////////

        //if ghost timer is up, set ghosts to normal mode

        if ( vulnflag && time > ghosttick ) {
            for (i=0;i<4;i++) {
                if ( ((Ghost*)objects[i+2])->getState() != 3) ((Ghost*)objects[i+2])->setState(0);
            }
            vulnflag= false;
            deadghostcount= 0;

            app.getSnd()->stop(7);
        }

        // if less than 2 secs left in vuln mode, set warning mode

        else if ( vulnflag && time > ghosttick -2000) for (i=0;i<4;i++) {
            ((Ghost*)objects[i+2])->setState(2);
            //			app.getSnd()->modify( 7, 44100 + (2000 - (ghosttick-time))*10 );
        }

        // fruit stuff

        if ( specialspawned && !specialeaten && (fruittick - time < 2000) ) {
            ((BckgrObj*)objects[0])->setFruitAlpha( 55 + (fruittick - time) / 10 );
        }
        if ( time > fruittick && specialspawned && !specialeaten) {
            specialspawned = false;
            ((BckgrObj*)objects[0])->setSpecialSpawned(false);
        }

        // pac booster

        if ( isboosted && time > boosttick ) {
            isboosted = false;
            ((Pacman*)objects[PAC])->setSpeedMult( 1 );
        }

        ///////////////////////////////////////////
        // PACMAN LOCATION LOGIC
        ///////////////////////////////////////////

        for (i=0; i< 4; i++) {
            //if (pacX == baddieX[i] && pacY == baddieY[i] ) {
            Position pacPos(pacXpix, pacYpix);
            Position ghostPos(ghostXpix[i], ghostYpix[i]);
            if (pacPos.distanceTo(ghostPos) < 20) {

                if ( ((Ghost*)objects[i+2])->getState() == 0 )	{

                    lives--;

                    app.getSnd()->stop();
                    app.getSnd()->play(8, 0);

                    SDL_Delay(1000);

                    if ( lives == 0) {
                        unsigned int finalScore = static_cast<unsigned int>(score); // Captura antes do reset provocado por gameInit().
                        bool qualifiesForRanking = hscore.onlist(finalScore);

                        gameInit();

                        hasRecentGameOver = true;
                        lastRecordedScore = finalScore;
                        rankingFromHotkey = false;
                        gamestarted = false;

                        if (qualifiesForRanking) {
                            awaitingHighscoreEntry = true;
                            name = "AAA";
                            namecol[0] = 255;
                            namecol[1] = 150;
                            namecol[2] = 150;
                            lastRecordedName.clear();
                            setState( STATE_ENTER_HSCORE );
                        }
                        else {
                            awaitingHighscoreEntry = false;
                            lastRecordedName.clear();
                            setState( STATE_VIEW_HSCORE );
                        }
                        return;
                    }
                    else {
                        resetLvl();
                        return;
                    }
                }

                else if  ( ((Ghost*)objects[i+2])->getState() != 3 ) {
                    ((Ghost*)objects[i+2])->setState(3);

                    app.getSnd()->play(4,0);
                    deadghostcount++;

                    floatingscore = 200;
                    for (j=1; j< deadghostcount; j++) floatingscore *= 2;
                    floatingscorebox.x = pacXpix;
                    floatingscorebox.w = 100;
                    floatingscorebox.y = pacYpix-70;
                    floatingscorebox.h = 50;

                    floatingscorecounter = 100;

                    score+= floatingscore;
                }
            }
        }

        if ( objmap[pacY * settings.fieldwidth + pacX ] == 1 ) {
            objmap[pacY * settings.fieldwidth + pacX ] = 0;
            score += SMALL_DOTS_SCORE;

            app.getSnd()->play( 1 + soundcounter%2, 0, -500);
            soundcounter++;
        }
        else if ( objmap[pacY * settings.fieldwidth + pacX ] == 2 ) {
            objmap[pacY * settings.fieldwidth + pacX ] = 0;
            score += LARGE_DOTS_SCORE;

            app.getSnd()->play(3, 0);
            app.getSnd()->play(7, 1);

            //set ghosts to vulnerable mode

            for (i=2;i<6;i++) ((Ghost*)objects[i])->setState(1);
            deadghostcount=0;	//reset dead counter

            //start ghost timer

            ghosttick = time + settings.vuln_duration;
            vulnflag = true;
        }
        else if ( objmap[pacY * settings.fieldwidth + pacX ] == 3 &&  specialspawned && !specialeaten ) {
            objmap[pacY * settings.fieldwidth + pacX ] = 0;
            score += objscore;

            app.getSnd()->play(5, 0);

            floatingscorebox.x = pacXpix;
            floatingscorebox.w = 100;
            floatingscorebox.y = pacYpix-70;
            floatingscorebox.h = 50;
            floatingscore = objscore;
            floatingscorecounter = 100;

            specialeaten = true;
            ((BckgrObj*)objects[0])->setSpecialEaten(true);
        }


        ///////////////////////////////////
        //	OTHER
        ///////////////////////////////////

        if ( (score >= 10000 && oldscore < 10000) ||
             (score >=100000 && oldscore < 100000) ||
             (score >=1000000 && oldscore < 1000000) ) {
            lives++;

            app.getSnd()->play(6, 0);
        }

        if ( !specialhasbeenspawned && ((BckgrObj*)objects[0])->getObjCount() == specialspawntime) {
            specialspawned = true;
            ((BckgrObj*)objects[0])->setFruitAlpha(255);
            ((BckgrObj*)objects[0])->setSpecialSpawned(true);
            fruittick = SDL_GetTicks() + FRUITDURATION;
        }

        if ( ((BckgrObj*)objects[0])->getObjCount() == 0 ) {
            levelcleared = true;
            render();
            nextLvl();
        }
        //		else ( app.getSnd()->modify( 10, 44100 - ((BckgrObj*)objects[0])->getObjCount() * 75) );
    }
}
void Game::renderEnterHscore() {
    SDL_Renderer* renderer = app.getRenderer();
    shared_ptr<SDL_Surface> txt;
    std::ostringstream ostr;
    SDL_Rect rect;
    SDL_Color col;
    int i;
    std::string tmp;

    col.r = col.g = col.b = 255;

    rect.x = settings.fieldwidth*settings.tilesize / 2 - 200;
    rect.w = 400;
    rect.y = settings.fieldheight*settings.tilesize / 2 - 50;
    rect.h = 50;

    try {
        // DRAW FIELD + SPRITES

        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->Draw();

        // DRAW SCORE + INFO

        for (i=1; i<lives; i++) {
            objects[PAC]->Draw( 350+i*50, settings.fieldheight*settings.tilesize+5);
        }
        if ( specialeaten ) objects[0]->Draw( settings.fieldwidth*settings.tilesize - 40 -10, settings.fieldheight*settings.tilesize +15 );

        if (hasRecentGameOver)
            ostr << "PONTUAÇÃO FINAL: " << lastRecordedScore;
        else
            ostr << "level: " << level << " score: " << score;

        txt.reset(TTF_RenderUTF8_Solid(font,ostr.str().c_str(),col), SDL_FreeSurface);
        if (!txt) throw Error("DrawText failed");
        SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, txt.get());
        if (texture) {
            SDL_Rect textRect = {scorebox.x, scorebox.y, txt->w, txt->h};
            SDL_RenderCopy(renderer, texture, NULL, &textRect);
            SDL_DestroyTexture(texture);
        }

        // DRAW HIGHSCORE ENTRY


        txt.reset(TTF_RenderUTF8_Solid(font,"NEW HIGHSCORE!",col), SDL_FreeSurface);
        if (!txt) throw Error("DrawText failed");
        texture = SDL_CreateTextureFromSurface(renderer, txt.get());
        if (texture) {
            SDL_Rect textRect = {rect.x, rect.y, txt->w, txt->h};
            SDL_RenderCopy(renderer, texture, NULL, &textRect);
            SDL_DestroyTexture(texture);
        }

        rect.y += 50;


        txt.reset(TTF_RenderUTF8_Solid(font,"Enter name:",col), SDL_FreeSurface);
        if (!txt) throw Error("DrawText failed");
        texture = SDL_CreateTextureFromSurface(renderer, txt.get());
        if (texture) {
            SDL_Rect textRect = {rect.x, rect.y, txt->w, txt->h};
            SDL_RenderCopy(renderer, texture, NULL, &textRect);
            SDL_DestroyTexture(texture);
        }

        rect.y += 70;
        rect.h = 50;
        rect.x = settings.fieldwidth*settings.tilesize / 2 - 60;
        rect.w = 40;

        for (i=0;i<3;i++) {
            tmp=name[i];
            col.r=col.g=col.b=namecol[i];

            txt.reset(TTF_RenderUTF8_Solid(font,tmp.c_str(),col), SDL_FreeSurface);
            if (!txt) throw Error("DrawText failed");
            texture = SDL_CreateTextureFromSurface(renderer, txt.get());
            if (texture) {
                SDL_Rect textRect = {rect.x, rect.y, txt->w, txt->h};
                SDL_RenderCopy(renderer, texture, NULL, &textRect);
                SDL_DestroyTexture(texture);
            }

            rect.x=rect.x+40;
        }
    }
    catch ( Error& err ) {
        std::cerr << err.getDesc();
        app.setQuit(true);
        logtxt.print( err.getDesc() );
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::RenderEnterHscore";
        app.setQuit(true);
        logtxt.print( "Unexpected error" );
    }
}
void Game::renderNormal() {
    int i;
    std::ostringstream ostr;
    SDL_Color col;
    shared_ptr<SDL_Surface> txt;

    col.r = col.g = col.b = 255;

    try {
        // DRAW FIELD + SPRITES

        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->Draw();

        // DRAW SCORE + INFO

        for (i=1; i<lives; i++)
            objects[PAC]->Draw( 350+i*50, settings.fieldheight*settings.tilesize+5);

        if ( specialeaten ) objects[0]->Draw( settings.fieldwidth*settings.tilesize - 40 -10, settings.fieldheight*settings.tilesize +15 );
        if ( boostavailable ) objects[0]->Draw( settings.fieldwidth*settings.tilesize - 60 -10, settings.fieldheight*settings.tilesize +15, 4 );

        ostr << "level: " << level << " score: " << score;

        SDL_Renderer* renderer = app.getRenderer();
        txt.reset(TTF_RenderUTF8_Solid(font,ostr.str().c_str(),col), SDL_FreeSurface);
        if (!txt) throw Error("DrawText failed");
        SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, txt.get());
        if (texture) {
            SDL_Rect textRect = {scorebox.x, scorebox.y, txt->w, txt->h};
            SDL_RenderCopy(renderer, texture, NULL, &textRect);
            SDL_DestroyTexture(texture);
        }

        //DRAW SCORE POPUP
        if (floatingscorecounter != 0) {
            std::ostringstream scoretext;

            scoretext << floatingscore;
            floatingscorecounter--;

            floatingscorebox.y--;

            txt.reset(TTF_RenderUTF8_Solid(font,scoretext.str().c_str(),col), SDL_FreeSurface);
            if (!txt) throw Error("DrawText failed");
            texture = SDL_CreateTextureFromSurface(renderer, txt.get());
            if (texture) {
                SDL_SetTextureAlphaMod(texture, 55+floatingscorecounter*2);
                SDL_Rect textRect = {floatingscorebox.x, floatingscorebox.y, txt->w, txt->h};
                SDL_RenderCopy(renderer, texture, NULL, &textRect);
                SDL_DestroyTexture(texture);
            }
        }

        // PAUSE

        if ( ispaused ) {
            SDL_Rect pauserect;
            pauserect.y = settings.fieldwidth*settings.tilesize / 2 - 100;
            pauserect.w = 200;
            pauserect.x = settings.fieldheight*settings.tilesize / 2 - 10;
            pauserect.h = 50;

            txt.reset(TTF_RenderUTF8_Solid(font,"PAUSED",col), SDL_FreeSurface);
            if (!txt) throw Error("DrawText failed");
            texture = SDL_CreateTextureFromSurface(renderer, txt.get());
            if (texture) {
                SDL_Rect textRect = {pauserect.x, pauserect.y, txt->w, txt->h};
                SDL_RenderCopy(renderer, texture, NULL, &textRect);
                SDL_DestroyTexture(texture);
            }
        }

        // LEVEL CLEARED

        else if ( levelcleared ) {
            SDL_Rect pauserect;
            pauserect.x = settings.fieldwidth*settings.tilesize / 2 - 200;
            pauserect.w = 400;
            pauserect.y = settings.fieldheight*settings.tilesize / 2 - 10;
            pauserect.h = 50;

            txt.reset(TTF_RenderUTF8_Solid(font,"LEVEL CLEARED!",col), SDL_FreeSurface);
            if (!txt) throw Error("DrawText failed");
            texture = SDL_CreateTextureFromSurface(renderer, txt.get());
            if (texture) {
                SDL_Rect textRect = {pauserect.x, pauserect.y, txt->w, txt->h};
                SDL_RenderCopy(renderer, texture, NULL, &textRect);
                SDL_DestroyTexture(texture);
            }
        }
    }

    catch ( Error& err ) {
        std::cerr << err.getDesc();
        app.setQuit(true);
        logtxt.print( err.getDesc() );
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::RenderNormal";
        app.setQuit(true);
        logtxt.print( "Unexpected error during RenderNormal()" );
    }
}

void Game::boost() {
    if ( boostavailable ) {

        app.getSnd()->play( 12, 0 );

        boosttick = SDL_GetTicks() + BOOSTTIME;
        isboosted = true;
        boostavailable = false;
        ((Pacman*)objects[PAC])->setSpeedMult( 2 );
    }
}
bool Game::pause() {
    int i;

    if ( !ispaused ) {
        ispaused = true;
        app.getSnd()->stop();
        for (i=0;i<NUMOFOBJECTS;i++) objects[i]->setPaused( true);

        pausetick = SDL_GetTicks();

        return ispaused;
    }
    else {
        ispaused = false;
        app.getSnd()->play(10, 1);
        if (vulnflag) app.getSnd()->play(7, 1);
        for (i=0;i<NUMOFOBJECTS;i++) objects[i]->setPaused( false);

        int delta( SDL_GetTicks() - pausetick );

        ghosttick += delta;
        fruittick += delta;
        boosttick += delta;

        return ispaused;
    }
}
void Game::nextLvl() {
    std::string tmpstr;


    try {
        level++;

        app.getSnd()->stop();
        app.getSnd()->play(9);

        objscore*=2;
        settings.vuln_duration -= settings.vuln_duration/10;

        ((Ghost*)objects[ rand()%4 +2])->changeDifficulty( rand()%15, rand()%5 );
        ((Ghost*)objects[ rand()%4 +2])->changeDifficulty( rand()%10, rand()%3 );

        objects[PAC]->reset(settings.pacstartx, settings.pacstarty);
        objects[GHOST1]->reset(settings.baddiestartx, settings.baddiestarty);
        objects[GHOST2]->reset(settings.baddiestartx+2, settings.baddiestarty);
        objects[GHOST3]->reset(settings.baddiestartx-2, settings.baddiestarty);
        objects[GHOST4]->reset(settings.baddiestartx, settings.baddiestarty-2);

        tmpstr = (settings.lvlpath[settings.lvlpathcurrent] / OBJFILE).string();
        if ( ! loadMap(tmpstr, objmap) )
            throw Error("Error loading objmap.txt during Game::nextLvl()");

        vulnflag= false;
        deadghostcount= 0;
        floatingscorecounter = 0;
        floatingscore = 0;
        specialspawned = false;
        ((BckgrObj*)objects[0])->setSpecialSpawned(false);
        specialeaten = false;
        ((BckgrObj*)objects[0])->setSpecialEaten(false);
        specialhasbeenspawned = false;
        time = oldtime = SDL_GetTicks();
        ghosttick = 0;
        isboosted = false;
        ((Pacman*)objects[PAC])->setSpeedMult( 1);
        boostavailable = true;
        levelcleared = false;

        if (ispaused) pause();


        SDL_Delay(1000);


        render();
        specialspawntime = rand() % (((BckgrObj*)objects[0])->getObjCount() -20) + 10;

        emptyMsgPump();
        inputwaiting = false;
        gamestarted = false;
    }
    catch ( Error &err) {
        std::cerr << err.getDesc();
        app.setQuit(true);
        logtxt.print( err.getDesc() );
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::nextLvl()";
        app.setQuit(true);
        logtxt.print( "Unexpected error" );
    }
}

void Game::gameInit(std::string level, std::string skin, bool editor) {
    int i;
    std::string tmpstr;

    try {
        isinit=false;
        app.getSnd()->stop();

        //try to set level/skins path
        settings.setPath(MODE_LEVELS,level);
        settings.setPath(MODE_SKINS,skin);

        tmpstr = (settings.lvlpath[settings.lvlpathcurrent] / CFGFILE).string();

        if ( !settings.LoadSettings(tmpstr) )
            throw Error("Error loading level settings");

        //resetting variables
        score=0;
        vulnflag= false;
        deadghostcount= 0;
        ghosttick = 0;
        floatingscorecounter = 0;
        floatingscore = 0;
        lives = 3;
        level = 1;
        objscore = 200;
        specialspawned = false;
        specialeaten = false;
        specialhasbeenspawned = false;
        inputwaiting = false;
        gamestarted = false;
        isboosted = false;
        time = oldtime = SDL_GetTicks();
        boostavailable = true;
        levelcleared = false;
        setState( STATE_GAME);
        name = "AAA";
        namecol[0] = 255;
        namecol[1] = 150;
        namecol[2] = 150;
        hscoreselection = 0;
        lastRecordedScore = 0;
        lastRecordedName.clear();
        hasRecentGameOver = false;
        awaitingHighscoreEntry = false;
        rankingFromHotkey = false;
        previousState = STATE_STOPPED;


        if ( ispaused )
            pause();

        scorebox.x= 20;
        scorebox.w = 500;
        scorebox.y = settings.fieldheight * settings.tilesize ;
        scorebox.h = 50;



        //DYNAMIC OBJECTS INIT
        if (map!=NULL) {
            delete[] map;
            map=NULL;
        }
        if (objmap!=NULL) {
            delete[] objmap;
            objmap=NULL;
        }
        for (i=0; i< NUMOFOBJECTS; i++) {
            if (objects[i]!=NULL) {
                delete objects[i];
                objects[i] = NULL;
            }
        }

        logtxt.print("Unloading complete");

        //if level has different field size than currently selected, setup new window with proper size
        int winW, winH;
        SDL_GetWindowSize(app.getWindow(), &winW, &winH);
        if (settings.fieldwidth*settings.tilesize != winW
            || settings.fieldheight*settings.tilesize+EXTRA_Y_SPACE != winH) {
            app.InitWindow();
            logtxt.print("window resized...");
        }

        // INIT MAPS
        map = new int[settings.fieldheight*settings.fieldwidth];
        objmap = new int[settings.fieldheight*settings.fieldwidth];

        tmpstr = settings.lvlpath[settings.lvlpathcurrent].string();

        if ( !loadMap((settings.lvlpath[settings.lvlpathcurrent] / MAPFILE).string(), map) )
            throw Error("Failed to load map.txt");
        if ( !loadMap((settings.lvlpath[settings.lvlpathcurrent] / OBJFILE).string(), objmap) )
            throw Error("Failed to load objmap.txt");

        logtxt.print("Maps loaded");

        //creating font

        if ( !font ) loadFont();

        logtxt.print("Font created");

        //loading level graphics

        objects[0] = new BckgrObj( app.getRenderer(), 10 );
        objects[0]->LoadTextures((PathUtils::getAppPath() / settings.skinspath[settings.skinspathcurrent]).string());

        logtxt.print("Level background loaded");

        logtxt.print("Sounds loaded");

        app.getSnd()->play(9, 0);

        setState( STATE_MENU); // Ao inicializar ou reiniciar, voltamos ao menu principal.

        hscore.setfilename((settings.lvlpath[settings.lvlpathcurrent] / "hscore").string());
        hscore.load();


        //create pacman + ghosts

        objects[1] = new Pacman( app.getRenderer(),
                            20,
                            settings.pacstartx,
                            settings.pacstarty,
                            settings.pacspeed,
                            settings.tilesize,
                            settings.fieldheight,
                            settings.fieldwidth,
                            map);
        objects[1]->LoadTextures((PathUtils::getAppPath() / settings.skinspath[settings.skinspathcurrent]).string());

        objects[2] = new Ghost( app.getRenderer(),
                            20,
                            settings.baddiestartx,
                            settings.baddiestarty,
                            settings.baddiespeed + rand()%20 + 10,
                            settings.tilesize,
                            settings.fieldheight,
                            settings.fieldwidth,
                            map,
                            "1");
        objects[2]->LoadTextures((PathUtils::getAppPath() / settings.skinspath[settings.skinspathcurrent]).string());

        objects[3] = new Ghost( app.getRenderer(),
                            20,
                            settings.baddiestartx+2,
                            settings.baddiestarty,
                            settings.baddiespeed + rand()%20-10,
                            settings.tilesize,
                            settings.fieldheight,
                            settings.fieldwidth,
                            map,
                            "2");
        objects[3]->LoadTextures((PathUtils::getAppPath() / settings.skinspath[settings.skinspathcurrent]).string());

        objects[4] = new Ghost( app.getRenderer(),
                            20,
                            settings.baddiestartx-2,
                            settings.baddiestarty,
                            settings.baddiespeed + rand()%20-10,
                            settings.tilesize,
                            settings.fieldheight,
                            settings.fieldwidth,
                            map,
                            "3");
        objects[4]->LoadTextures((PathUtils::getAppPath() / settings.skinspath[settings.skinspathcurrent]).string());

        objects[5] = new Ghost( app.getRenderer(),
                            20,
                            settings.baddiestartx,
                            settings.baddiestarty-2,
                            settings.baddiespeed + rand()%20 - 10,
                            settings.tilesize,
                            settings.fieldheight,
                            settings.fieldwidth,
                            map,
                            "4");
        objects[5]->LoadTextures((PathUtils::getAppPath() / settings.skinspath[settings.skinspathcurrent]).string());

        for (i=0;i<4;i++) ((Ghost*)objects[i+2])->changeDifficulty(0, settings.baddieiq);	//SET DIFFICULTY SPECIFIED IN CONFIG FILE

        logtxt.print("Objects loaded");

        //calculate special fruit spawn time

        if (!editor) render();
        specialspawntime = rand() % (((BckgrObj*)objects[0])->getObjCount() -20) + 10;

        emptyMsgPump();
        inputwaiting = false;
        gamestarted = false;

        isinit = true;

        if (editor) {
            initEditor();
            setState(STATE_EDITOR);
        }
    }
    catch ( Error &err) {
        std::cerr << err.getDesc();
        app.setQuit(true);
        logtxt.print( err.getDesc() );
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::gameInit()";
        app.setQuit(true);
        logtxt.print( "Unexpected error" );
    }
}


void Game::resetLvl() {	// vars and positions when pacman dies during level

    app.getSnd()->stop();

    SDL_Delay(1000);

    app.getSnd()->play(9);


    // setting vars
    vulnflag= false;
    deadghostcount= 0;
    floatingscorecounter= 0;
    floatingscore= 0;
    ghosttick = 0;
    isboosted = false;
    ((Pacman*)objects[PAC])->setSpeedMult( 1);

    if (ispaused) pause();

    objects[PAC]->reset(settings.pacstartx, settings.pacstarty);
    objects[GHOST1]->reset(settings.baddiestartx, settings.baddiestarty);
    objects[GHOST2]->reset(settings.baddiestartx+2, settings.baddiestarty);
    objects[GHOST3]->reset(settings.baddiestartx-2, settings.baddiestarty);
    objects[GHOST4]->reset(settings.baddiestartx, settings.baddiestarty-2);

    render();

    emptyMsgPump();
    gamestarted= false;
    inputwaiting = false;
}
void Game::processInput(int k, int ix, int iy) {

    inputwaiting = true;

    key = k;
    if ( k == CLICK ) {
        mouseX = ix;
        mouseY = iy;
    }

    if (!gamestarted && !ispaused && (state == STATE_STOPPED || state == STATE_GAME)) {
        gamestarted = true;
        setState( STATE_GAME ); // Evita marcar o jogo como iniciado durante navegação em outras telas (ex.: ranking).
    }
}

void Game::processLogic() {

    time = SDL_GetTicks();

    if ( state == STATE_MENU ) logicMenu();
    else if ( state == STATE_GAME ) logicGame();
    else if (state == STATE_ENTER_HSCORE ) logicEnterHscore();
    else if (state == STATE_EDITOR ) logicEditor();

    oldtime = time;
    inputwaiting = false;
}

void Game::logicMenu() {
    // Controla seleção das opções sem iniciar o loop de jogo.
    if ( inputwaiting ) {
        switch ( key ) {
        case UP:
            menuSelection = (menuSelection + 2) % 3; // Volta para o último item ao subir a partir do primeiro.
            break;
        case DOWN:
            menuSelection = (menuSelection + 1) % 3; // Avança ciclicamente entre os itens disponíveis.
            break;
        case ENTER:
            if ( menuSelection == 0 ) {
                previousState = STATE_MENU;
                gameInit(); // Reinicia recursos para garantir início limpo.
                setState( STATE_STOPPED );
            }
            else if ( menuSelection == 1 ) {
                rankingFromHotkey = false;
                previousState = STATE_MENU;
                setState( STATE_VIEW_HSCORE );
            }
            else if ( menuSelection == 2 ) {
                app.setQuit(true);
            }
            break;
        default:
            break;
        }
    }
}

void Game::getMaps( int **m, int **o) {
    (*m)=map;
    (*o)=objmap;
}
bool Game::loadMap(std::string file, int* memmap) {
    int i, count=0, size = settings.fieldheight * settings.fieldwidth;
    std::string tmp;
    char c('i');
    std::ifstream mp;

    file = settings.getFile(file);
    mp.open( file );

    if (!mp ) {
        logtxt.print(file + " - Loading error");
        app.setQuit(true);
        return false;
    }

    for (i=0;i<size;i++) {
        do {
            if ( mp.eof() ) break;
            c=mp.get();
            if (c == '/' ) {	// enable comments in map file by prefixing line with  a slash
                getline(mp, tmp);
                continue;
            }
        }
        while (! (c >= '0' && c <= '9') ) ;
        memmap[i]=c-48;
        count++;
        if (!mp) break;
    }

    if ( mp.is_open() ) mp.close();

    if (count != size) {
        logtxt.print(file + " - Loading error");
        app.setQuit(true);
        return false;
    }

    logtxt.print(file + " loaded");
    return true;
}


std::string Game::getFPS() {
    unsigned int newtick = SDL_GetTicks();
    std::ostringstream ostr;
    float diff;

    diff = (float)(newtick-ticks) / (float)counter;	// ms per frame

    diff = 1000.0f / diff;			// frames per s

    ostr << diff << "fps";

    ticks = newtick;

    return ostr.str();
}

void Game::render() {
    SDL_Renderer* renderer = app.getRenderer();
    SDL_Color col;

    col.r = col.g = col.b = 255;

    if (counter == 100) {
        fps = getFPS();
        counter = 0;
    }

    try {
        if ( !renderisbusy ) {
            renderisbusy = true;

            // Clear renderer
            SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
            SDL_RenderClear(renderer);

            ////////////////////////////////
            // STATE SWITCH
            ////////////////////////////////

            if ( state == STATE_MENU ) renderMenu();
            else if ( (state == STATE_GAME) || (state == STATE_STOPPED) ) renderNormal();
            else if (state == STATE_ENTER_HSCORE ) renderEnterHscore();
            else if (state == STATE_VIEW_HSCORE ) renderViewHscore();
            else if (state == STATE_EDITOR )renderEditor();


            if ( showfps ) {
                shared_ptr<SDL_Surface> txt(TTF_RenderUTF8_Solid(font,fps.c_str(),col), SDL_FreeSurface);
                if (!txt) throw Error("DrawText failed");

                SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, txt.get());
                if (texture) {
                    SDL_Rect textRect = {fpsbox.x, fpsbox.y, txt->w, txt->h};
                    SDL_RenderCopy(renderer, texture, NULL, &textRect);
                    SDL_DestroyTexture(texture);
                }
            }

            SDL_RenderPresent(renderer);

            renderisbusy = false;
            counter++;
        }
    }
    catch ( Error& err ) {
        std::cerr << err.getDesc();
        app.setQuit(true);
        logtxt.print( err.getDesc() );
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::Render";
        app.setQuit(true);
        logtxt.print( "Unexpected error during Render()" );
    }
}

bool Game::loadFont() {

    try {
        font = TTF_OpenFont((PathUtils::getAppPath() / "arial.ttf").string().c_str(), 24);
        if (!font)
            throw Error("Failed to create font object ");

        const std::string menuFontPath = (PathUtils::getAppPath() / "PAC-FONT.ttf").string();
        menuFont = TTF_OpenFont(menuFontPath.c_str(), 20);
        if (!menuFont) {
            std::ostringstream fontError;
            fontError << "Failed to create menu font object (" << menuFontPath << ") : " << TTF_GetError();
            throw Error(fontError.str());
        }
    }
    catch ( Error& err ) {
        std::cerr << err.getDesc();
        app.setQuit(true);
        logtxt.print( err.getDesc() );
        return false;
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::loadFont";
        app.setQuit(true);
        logtxt.print( "Unexpected error while loading font" );
        return false;
    }

    logtxt.print("Font loaded");
    return true;
}

void Game::PrepareShutdown() {
    int i;

    if ( font ) TTF_CloseFont(font);
    if ( menuFont ) TTF_CloseFont(menuFont);
    for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) delete objects[i];
}
Game::Game()
:   isinit(false),
    state(STATE_MENU),
    counter(0),
    font(NULL),
    menuFont(NULL),
    map(NULL),
    objmap(NULL),
    deadghostcount(0),
    lives(2),
    objscore(200),
    floatingscore(0),
    floatingscorecounter(0),
    specialspawntime(0),
    level(1),
    hscoreselection(0),
    lastRecordedScore(0),
    soundcounter(0),
    inputwaiting(false),
    gamestarted(false),
    vulnflag(false),
    specialspawned(false),
    specialeaten(false),
    specialhasbeenspawned(false),
    ispaused(false),
    isboosted(false),
    showfps(false),
    renderisbusy(false),
    rankingFromHotkey(false),
    awaitingHighscoreEntry(false),
    hasRecentGameOver(false),
    previousState(STATE_STOPPED),
    menuSelection(0)

{
    int i;

    time = oldtime = ticks = SDL_GetTicks();

    fps = "loading";

    fpsbox.x= 10;
    fpsbox.w = 290;
    fpsbox.y = 10;
    fpsbox.h = 190;

    for (i=0;i<NUMOFOBJECTS;i++) objects[i]=NULL;

    for (i=0;i<10;i++)
        num[i]='0'+i;

    name = "AAA";
    namecol[0] = 255;
    namecol[1] = 150;
    namecol[2] = 150;
    lastRecordedName.clear();
}

Game::~Game()
{
    if ( map ) delete[] map;
    if ( objmap ) delete[] objmap;
}
